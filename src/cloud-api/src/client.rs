// Copyright Materialize, Inc. and contributors. All rights reserved.
//
// Use of this software is governed by the Business Source License
// included in the LICENSE file.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0.

// BEGIN LINT CONFIG
// DO NOT EDIT. Automatically generated by bin/gen-lints.
// Have complaints about the noise? See the note in misc/python/materialize/cli/gen-lints.py first.
#![allow(clippy::style)]
#![allow(clippy::complexity)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::mutable_key_type)]
#![allow(clippy::stable_sort_primitive)]
#![allow(clippy::map_entry)]
#![allow(clippy::box_default)]
#![warn(clippy::bool_comparison)]
#![warn(clippy::clone_on_ref_ptr)]
#![warn(clippy::no_effect)]
#![warn(clippy::unnecessary_unwrap)]
#![warn(clippy::dbg_macro)]
#![warn(clippy::todo)]
#![warn(clippy::wildcard_dependencies)]
#![warn(clippy::zero_prefixed_literal)]
#![warn(clippy::borrowed_box)]
#![warn(clippy::deref_addrof)]
#![warn(clippy::double_must_use)]
#![warn(clippy::double_parens)]
#![warn(clippy::extra_unused_lifetimes)]
#![warn(clippy::needless_borrow)]
#![warn(clippy::needless_question_mark)]
#![warn(clippy::needless_return)]
#![warn(clippy::redundant_pattern)]
#![warn(clippy::redundant_slicing)]
#![warn(clippy::redundant_static_lifetimes)]
#![warn(clippy::single_component_path_imports)]
#![warn(clippy::unnecessary_cast)]
#![warn(clippy::useless_asref)]
#![warn(clippy::useless_conversion)]
#![warn(clippy::builtin_type_shadow)]
#![warn(clippy::duplicate_underscore_argument)]
#![warn(clippy::double_neg)]
#![warn(clippy::unnecessary_mut_passed)]
#![warn(clippy::wildcard_in_or_patterns)]
#![warn(clippy::collapsible_if)]
#![warn(clippy::collapsible_else_if)]
#![warn(clippy::crosspointer_transmute)]
#![warn(clippy::excessive_precision)]
#![warn(clippy::overflow_check_conditional)]
#![warn(clippy::as_conversions)]
#![warn(clippy::match_overlapping_arm)]
#![warn(clippy::zero_divided_by_zero)]
#![warn(clippy::must_use_unit)]
#![warn(clippy::suspicious_assignment_formatting)]
#![warn(clippy::suspicious_else_formatting)]
#![warn(clippy::suspicious_unary_op_formatting)]
#![warn(clippy::mut_mutex_lock)]
#![warn(clippy::print_literal)]
#![warn(clippy::same_item_push)]
#![warn(clippy::useless_format)]
#![warn(clippy::write_literal)]
#![warn(clippy::redundant_closure)]
#![warn(clippy::redundant_closure_call)]
#![warn(clippy::unnecessary_lazy_evaluations)]
#![warn(clippy::partialeq_ne_impl)]
#![warn(clippy::redundant_field_names)]
#![warn(clippy::transmutes_expressible_as_ptr_casts)]
#![warn(clippy::unused_async)]
#![warn(clippy::disallowed_methods)]
#![warn(clippy::disallowed_macros)]
#![warn(clippy::disallowed_types)]
#![warn(clippy::from_over_into)]
// END LINT CONFIG

use std::time::Duration;

use once_cell::sync::Lazy;
use reqwest::{Method, RequestBuilder, Url};
use serde::{de::DeserializeOwned, Deserialize};

use crate::client::errors::{ApiError, CloudApiError};

pub static DEFAULT_ENDPOINT: Lazy<Url> =
    Lazy::new(|| "https://cloud.materialize.com".parse().unwrap());

/// Configures a `Client`.
pub struct ClientBuilder {
    endpoint: Url,
}

pub struct ClientConfig {
    frontegg_client: mz_frontegg_auth::client::Client,
}

impl Default for ClientBuilder {
    fn default() -> ClientBuilder {
        ClientBuilder {
            endpoint: DEFAULT_ENDPOINT.clone(),
        }
    }
}

impl ClientBuilder {
    /// Overrides the default endpoint.
    pub fn endpoint(mut self, url: Url) -> ClientBuilder {
        self.endpoint = url;
        self
    }

    /// Creates a [`Client`] that incorporates the optional parameters
    /// configured on the builder and the specified required parameters.
    pub fn build(self, config: ClientConfig) -> Client {
        let inner = reqwest::ClientBuilder::new()
            .redirect(reqwest::redirect::Policy::none())
            .timeout(Duration::from_secs(60))
            .build()
            .unwrap();

        Client {
            frontegg_client: config.frontegg_client,
            auth: None,
            endpoint: self.endpoint,
            inner,
        }
    }
}

pub struct Auth {
    token: String,
}

pub struct Client {
    inner: reqwest::Client,
    frontegg_client: mz_frontegg_auth::client::Client,
    auth: Option<Auth>,
    endpoint: Url,
}

pub mod cloud_provider;
pub mod environment;
pub mod errors;
pub mod region;

/// Cloud endpoints architecture:
///
///                           rc = region controller                   ec = environment controller
///                     rc.{region}.{provider}.{endpoint}         ec.{n}.{region}.{provider}.{endpoint}
///  ---------        --------------------------------------             ------------------------
/// |          |      |          Region Controller           |          | Environment Controller |
/// |  Cloud   |      |    ----------        -------------   |          |                        |
/// |  Sync    | ---- |   | Provider | ---- |    Region   |  | -------- |       Environment      |
/// |          |      |   | (aws..)  |      |  (east-1..) |  |          |  (pgwire_address...)   |
/// |          |      |    ----------        -------------   |          |                        |
///  ----------        --------------------------------------             -----------------------
///
impl Client {
    /// Builds a request towards the `Client`'s endpoint
    fn build_request<P>(&self, method: Method, path: P) -> RequestBuilder
    where
        P: IntoIterator,
        P::Item: AsRef<str>,
    {
        let mut url = self.endpoint.clone();
        url.path_segments_mut()
            .expect("builder validated URL can be a base")
            .clear()
            .extend(path);
        self.inner.request(method, url)
    }

    /// Builds a request towards the `Client`'s endpoint
    fn build_request_with_subdomain<P>(
        &self,
        method: Method,
        path: P,
        subdomain: &str,
    ) -> RequestBuilder
    where
        P: IntoIterator,
        P::Item: AsRef<str>,
    {
        let mut url = self.endpoint.clone();

        // Set the new host using a subdomain
        let host = format!("{}.{}", subdomain, url.host().unwrap().to_owned());
        url.set_host(Some(&host)).unwrap();

        url.path_segments_mut()
            .expect("builder validated URL can be a base")
            .clear()
            .extend(path);

        self.inner.request(method, url)
    }

    async fn request<P>(&self, method: Method, path: P) -> Result<RequestBuilder, CloudApiError>
    where
        P: IntoIterator,
        P::Item: AsRef<str>,
    {
        // Makes a request using the frontegg client's authentication.
        let req = self.build_request(method, path);
        let token = self.frontegg_client.auth().await.unwrap().token;
        Ok(req.bearer_auth(token))
    }

    async fn request_with_subdomain<P>(
        &self,
        method: Method,
        path: P,
        subdomain: &str,
    ) -> Result<RequestBuilder, CloudApiError>
    where
        P: IntoIterator,
        P::Item: AsRef<str>,
    {
        // Makes a request using the frontegg client's authentication.
        let req = self.build_request_with_subdomain(method, path, subdomain);
        let token = self.frontegg_client.auth().await.unwrap().token;
        Ok(req.bearer_auth(token))
    }

    async fn send_request<T>(&self, req: RequestBuilder) -> Result<T, CloudApiError>
    where
        T: DeserializeOwned,
    {
        #[derive(Deserialize)]
        #[serde(rename_all = "camelCase")]
        struct ErrorResponse {
            #[serde(default)]
            message: Option<String>,
            #[serde(default)]
            errors: Vec<String>,
        }

        let res = req.send().await?;
        let status_code = res.status();
        if status_code.is_success() {
            Ok(res.json().await?)
        } else {
            match res.json::<ErrorResponse>().await {
                Ok(e) => {
                    let mut messages = e.errors;
                    messages.extend(e.message);
                    Err(CloudApiError::Api(ApiError {
                        status_code,
                        messages,
                    }))
                }
                Err(_) => Err(CloudApiError::Api(ApiError {
                    status_code,
                    messages: vec!["unable to decode error details".into()],
                })),
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use mz_frontegg_auth::app_password::AppPassword;

    use crate::client::{Client, ClientBuilder, ClientConfig};

    #[tokio::test]
    async fn test_app_password() {
        struct TestCase {
            psw: &'static str,
        }

        let app_password: AppPassword = env!("MZ_PSW").parse().unwrap();
        println!("{}", app_password);
        let frontegg_client =
            mz_frontegg_auth::client::Client::new(mz_frontegg_auth::config::ClientConfig {
                app_password,
            });
        let client: Client = ClientBuilder::default().build(ClientConfig { frontegg_client });

        // List all the available providers
        let cloud_providers = client.list_cloud_providers().await.unwrap();
        assert!(cloud_providers.len() == 2);

        // Get all the environments
        let all_environments = client.get_all_environments().await.unwrap();
        assert!(all_environments.len() == 2);

        let cloud_provider = cloud_providers.iter().find(|cp| cp.id == "aws/us-east-1").unwrap().to_owned();

        // Get a a region using a cloud provider
        let region = client.get_region(cloud_provider).await.unwrap();

        assert!(
            region.environment_controller_url.to_string()
                == "https://ec.0.us-east-1.aws.cloud.materialize.com/"
        );

        let environment = client.get_environment(region).await.unwrap();

        assert!(
            environment.environmentd_https_address
                == "da8gqtiy8g8jx8ni5c5g9gri0.us-east-1.aws.materialize.cloud:443"
        );
    }
}
